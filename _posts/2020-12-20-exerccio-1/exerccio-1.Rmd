---
title: "Exercício 1"
description: |
  Sobre OneMax e BinInt
author:
  - name: Athos Damiani
date: 12-20-2020
output:
  distill::distill_article:
    self_contained: false
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

## Conclusão e discussão

- Em geral, quando se tem 10 cromossomos (ou bits) não houve problemas em convergir em 10 gerações. Até para os casos com 2 torneios apenas, as melhores soluções continham o ótimo global.

- Para 100 ou mais cromossomos, 8 torneios foram mais efetivos para encontrar boas soluções em 10 gerações. Principalmente para a função `BinInt` que tendia a ter soluções muito diversas.

- `BinInt` teve problemas numéricos em virtude da larga escala. Além disso, soluções com o bit mais alto (por exemplo `2^100` no caso do tamanho 100 de cromossomos) tendiam a dominar e deixar os demais bits quase que aleatórios.

## Códigos e Gráficos

### Setups e funções auxiliares

```{r}
library(reticulate)
library(purrr)
library(ggplot2)
library(tidyverse)
library(glue)
theme_set(theme_gray(16))
```

```{python}
import deap
import random
from deap import creator, base, tools, algorithms
import numpy as np 
from matplotlib import pyplot
```


```{python}
def evalOneMax(individual):
#    return sum(individual),   # ',' to compose tuple structure that is required by other operations
    return sum(individual),0   # ',' to compose tuple structure that is required by other operations

def fTrap5(individual):
    u = sum(individual)
    if u < 5:
      return 4-u , 0
    else:
      return 5 , 0

def fNTrap5(individual,k=5): # the function works for k< 5 and k>5, be carefull in comprehend results of it
  f = 0
  #refactoring individual into building blocks (bbs) of size k, l//k bbs
  #bbs = np.reshape(individual, (-1, k)) # -1 --> other dimension size is free, and calculated for consistency
  #in the case l//k isn' integer, reshape() doesn't work
  l = len(individual)
  r = l//k # r BBs of size k
  small_bb = l%k 
  for i in range(0,l-l//k,k):
    #print(i)
    bbk = individual[i:i+k]
    x,__ = fTrap5(bbk)
    f += x
  if small_bb > 0:
    bbk = individual[i+k:i+small_bb]
    x,__ = fTrap5(bbk)
    f += x
  return f,0
  
def evalBinInt(individual):
  binInt = 0
  for i in range(len(individual)):
    binInt += individual[i]*(2**i)/1e10
  return binInt,0
  
```

```{r}
population <- t(apply(rbind(diag(5), 0), 1, cumsum))
row.names(population) <- paste0("pop", 1:nrow(population))
population
```


```{r, fig.width=10}
OneMax_R <- function(x) py$evalOneMax(x)[[1]]
fNTrap5_R <- function(x) py$fNTrap5(x)[[1]]
BinInt_R <- function(x) py$evalBinInt(x)[[1]]
bits <- rowSums(population)
onemax <- apply(population, 1, OneMax_R)
fntrap5 <- apply(population, 1, fNTrap5_R)
binint <- apply(population, 1, BinInt_R)

data.frame(
  bits = c(bits, bits, bits),
  fitness = c(onemax, fntrap5, binint),
  func = rep(c("onemax", "fntrap5", "binint"), each = length(bits))
) %>%
  ggplot(aes(x = bits, y = fitness, colour = func)) +
  geom_line() +
  geom_point() +
  scale_fill_manual(values = c("onemax" = "royalblue", "fntrap5" = "orange", "binint" = "salmon")) +
  facet_wrap(~func, scales = "free_y")
```


```{python}
# creators
creator.create("FitnessMax", base.Fitness, weights=(1,))
creator.create("Individual", list, fitness = creator.FitnessMax)
creator.create("Population", list)
```

```{python}
def prepare_toolbox(fitness, n_chromossomes, n_torneios):
  # toolbox
  toolbox = base.Toolbox()
  toolbox.register("attr_bool", random.randint, 0, 1)
  toolbox.register("individual", tools.initRepeat, creator.Individual, toolbox.attr_bool, n = n_chromossomes)
  toolbox.register("population", tools.initRepeat, creator.Population, toolbox.individual)

  # genetic operators
  toolbox.register("evaluate", fitness)
  toolbox.register("mate", tools.cxTwoPoint)
  toolbox.register("mutate", tools.mutFlipBit, indpb = 0.05)
  toolbox.register("select", tools.selTournament, tournsize = n_torneios)

  return toolbox
```

### OneMax

```{python}
# main function - run genetic algorithm
def runGA(fitness, n_chromossomes, n_torneios, npop = 1000, ngen = 10, cxpb = 0.7, mutpb = 0.1, bb = 1):
  # toolbox for ONEMAX
  toolbox_onemax = prepare_toolbox(fitness = fitness, n_chromossomes = n_chromossomes, n_torneios = n_torneios)
  
  # population
  pop = toolbox_onemax.population(npop)
  
  # evolution loop
  for g in range(ngen):
    offspring = algorithms.varAnd(pop, toolbox_onemax, cxpb=cxpb, mutpb=mutpb)
    fits = toolbox_onemax.map(toolbox_onemax.evaluate, offspring)
  
    for fit, ind in zip(fits, offspring):
          ind.fitness.values = fit
          
    pop = toolbox_onemax.select(offspring, k=len(pop))

  popselected = tools.selBest(pop, len(pop)//8)
  
  return {"population": pop, "populationSelected": popselected}

```

```{python}
# setup
NGEN = 10
CXPB = 0.7
MUTPB = 0.1
NPOP = 1000

BB = [1]
NCHROMOSSOMES = [10,100,1000]
NTOURNAMENTS = [2,4,8]

# parameters loop
pops = {}
popsels = {}
r = {}
for b in range(len(BB)):
  for n in range(len(NCHROMOSSOMES)):
    for t in range(len(NTOURNAMENTS)):
      r = runGA(evalOneMax, NCHROMOSSOMES[n], NTOURNAMENTS[t], NPOP, NGEN, CXPB, MUTPB, BB[b])
      pops["chromossomes: {}; tournaments: {}; BB: {}".format(NCHROMOSSOMES[n], NTOURNAMENTS[t], BB[b])] = r["population"]
      popsels["chromossomes: {}; tournaments: {}; BB: {}".format(NCHROMOSSOMES[n], NTOURNAMENTS[t], BB[b])] = r["populationSelected"]

```

```{r}
parse_runGA_to_dataframe <- function(py_obj, fitness_f, pop = "unkown") {
  tibble(
    n_t = names(py_obj),
    individual = py_obj,
    pop = pop
  ) %>%
    mutate(
      individual = map(individual, ~{.x %>% map(~.x$copy())})
    ) %>%
    unnest(individual) %>%
    mutate(fitness = map_dbl(individual, fitness_f)) %>%
    separate(n_t, c("n", "t", "b"), sep = ";")
}
```

```{r}
population <- parse_runGA_to_dataframe(py$pops, OneMax_R, "population")
population_selected <- parse_runGA_to_dataframe(py$popsels, OneMax_R, "selected")
population <- bind_rows(population, population_selected)
title <- glue("NGEN: {py$NGEN}; CXPB = {py$CXPB}; MUTPB: {py$MUTPB}; NPOP: {py$NPOP}")
```



**Parameters:** `r title`

```{r, fig.height=16, fig.width=16, echo = FALSE}

p <- population %>%
  ggplot(aes(x = fitness, fill = pop, colour = pop)) +
  scale_fill_manual(values = c("population" = "royalblue", "selected" = "orange")) +
  scale_colour_manual(values = c("population" = "royalblue", "selected" = "orange")) +
  facet_wrap( ~ b + t + n, scales = "free", ncol = 3) 

p_hist <- p + geom_histogram(position = "identity", binwidth = 1, show.legend = FALSE)
p_dens <- p + geom_density(alpha = 0) 

library(patchwork)
(p_hist + p_dens)
```


### BinInt

(same code, just switching from OneMax to BinInt fitness...)

```{python, echo = FALSE}
# setup
NGEN = 10
CXPB = 0.7
MUTPB = 0.1
NPOP = 1000

BB = [1]
NCHROMOSSOMES = [10,100,1000]
NTOURNAMENTS = [2,4,8]

# parameters loop
pops = {}
popsels = {}
r = {}
for b in range(len(BB)):
  for n in range(len(NCHROMOSSOMES)):
    for t in range(len(NTOURNAMENTS)):
      r = runGA(evalBinInt, NCHROMOSSOMES[n], NTOURNAMENTS[t], NPOP, NGEN, CXPB, MUTPB, BB[b])
      pops["chromossomes: {}; tournaments: {}; BB: {}".format(NCHROMOSSOMES[n], NTOURNAMENTS[t], BB[b])] = r["population"]
      popsels["chromossomes: {}; tournaments: {}; BB: {}".format(NCHROMOSSOMES[n], NTOURNAMENTS[t], BB[b])] = r["populationSelected"]

```

**Top5 Solutions for chromossomes: 100; tournaments: 8; BB: 1**

```{r}
population_selected %>% 
  dplyr::filter(n == "chromossomes: 100", t == " tournaments: 8", b == " BB: 1") %>%
  head(5) %>%
  pull(individual) %>%
  do.call(rbind, .) %>%
  `rownames<-`(paste0("pop", 1:5))
```


```{r, echo = FALSE}
population <- parse_runGA_to_dataframe(py$pops, BinInt_R, "population")
population_selected <- parse_runGA_to_dataframe(py$popsels, BinInt_R, "selected")
population <- bind_rows(population, population_selected)
title <- glue("NGEN: {py$NGEN}; CXPB = {py$CXPB}; MUTPB: {py$MUTPB}; NPOP: {py$NPOP}")
```

**Parameters:** `r title`

```{r, fig.height=16, fig.width=16, echo = FALSE}

p <- population %>%
  ggplot(aes(x = fitness, fill = pop, colour = pop)) +
  scale_fill_manual(values = c("population" = "royalblue", "selected" = "orange")) +
  scale_colour_manual(values = c("population" = "royalblue", "selected" = "orange")) +
  facet_wrap( ~ b + t + n, scales = "free", ncol = 3) 

p_hist <- p + geom_histogram(position = "identity", binwidth = 1, show.legend = FALSE) + scale_x_log10()
p_dens <- p + geom_density(alpha = 0)  + scale_x_log10()

library(patchwork)
(p_hist + p_dens)
```



